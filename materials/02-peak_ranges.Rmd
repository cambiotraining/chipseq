---
title: Exploring peak ranges
---

```{r setup, echo=FALSE, purl=FALSE, cache=FALSE}
knitr::opts_chunk$set(cache = TRUE, 
                      cache.path = "../_cache/",
                      warning = FALSE, 
                      message = FALSE, 
                      cache.lazy = FALSE,
                      purl = TRUE)
knitr::opts_knit$set(root.dir = "../course_files/participants/")
```

```{r purl, eval=FALSE, echo=FALSE, purl=FALSE}
# note to trainers
# to generate script for participants run from the parent directory: 
knitr::purl("materials//02-peak_ranges.Rmd", 
            "course_files//participants/scripts/02-peak_ranges.R", 
            documentation = 0)
```


::: {.callout-tip}
#### Learning Objectives

- Import and manipulate peak ranges with dedicated R/Bioconductor packages.
- Become familiar with `GRanges` objects and how to use them for interval-based operations.
- Calculate and visualise peak occupancy across replicates. 
- Annotate peaks based on known gene annotations.
- Visualise peak profiles as a heatmap.

:::

## Peak ranges

Although the `nf-core/chipseq` workflow generates a peak consensus BED file, it is useful to know how to read and manipulate peak files ourselves. 
For example, we may want to change our criteria for defining a consensus peak (e.g. require an overlap across more replicates), annotate our peaks, or filter them based on different criteria. 

In this section, we will see how we can achieve this using dedicated R/Bioconductor packages, designed to work with genomic interval data. 
The main object used to represent genome intervals in R is called `GRanges`, which is part of the [Bioconductor GenomicRanges package](https://bioconductor.org/packages/release/bioc/vignettes/GenomicRanges/inst/doc/GenomicRangesIntroduction.html). 

This object requires at least three pieces of information:

- chromosome names (`seqnames`);
- interval start and end positions (`ranges`);
- and strand orientation, either `+` forward or `-` reverse (`strand`).

In addition, further columns can store additional information, such GC content in the interval, gene annotations overlapping that interval, etc.
Here is an example of a simple `GRanges` object:

```{r granges_demo1, echo=FALSE, purl=FALSE}
library(GenomicRanges)
gr <- GRanges(
    seqnames = Rle(c("chr1", "chr2", "chr1", "chr3"), c(1, 3, 2, 4)),
    ranges = IRanges(101:110, end = 111:120, names = head(letters, 10)),
    strand = Rle(strand(c("-", "+", "*", "+", "-")), c(1, 2, 2, 3, 2)),
    score = 1:10,
    GC = seq(1, 0, length=10),
    seqinfo = Seqinfo(seqnames = c("chr1", "chr2", "chr3"),
                      seqlengths = c(10e5, 20e4, 10e3), 
                      isCircular = c(FALSE, FALSE, FALSE),
                      genome = "example"))
gr
```

Here is a quick summary of functions used to access information from `GRanges` objects (the example code assumes the object is called `gr`):

```{r granges_demo2, purl=FALSE}
# total number of intervals
length(gr)

# sequence names (usually chromosomes)
# with number of intervals for each 
seqnames(gr)

# sequence names only
seqlevels(gr)

# sequence (chromosome) lengths
seqlengths(gr)
```

This type of object is ideal to represent ChIP peak calls, such as those identified by the MACS software. 
In the following sections we will show a concrete example of this in action. 

## Import peak files

To start our analysis, we start by loading the packages we will use:

```{r load_packages, cache=FALSE}
# Packages ----

# load packages
library(rtracklayer) # for importing BED/GFF/etc.
library(plyranges)   # for working with GenomicRanges
library(ChIPseeker)  # to annotate peaks
library(profileplyr) # for profile heatmaps
library(ggplot2)

# change the default ggplot theme
theme_set(theme_classic(base_size = 14))
```

The next step is to read information about our chromosome lengths, which is useful to make sure our `GRanges` object uses the correct information for our organism. 
We generated this information from our reference genome FASTA file and stored it as a tab-delimited file, which we read using standard R functions: 

```{r read_chroms}
# Chromosome info ----

# read chromosome sizes (for GRanges annotation)
chroms <- read.table("resources/GRCh38.109.chrom_sizes.tsv", 
                     col.names = c("seqnames", "seqlengths"))

# order chromosomes in a more intuititve manner
# and retain only autosomes (no contigs, no MT)
chroms <- chroms[match(c(1:22, "X", "Y"), chroms$seqnames), ]

# if you had MT, you can use this code to set it as circular
chroms$is_circular <- chroms$seqnames == "MT"

# view table
chroms
```

Because we have several peak files generated by MACS (one per sample and antibody), we will use some programmatic tricks to import them automatically, rather than having to repeat our code dozens of times. 

First, we find all the files that start with the word `brd4_`, followed by any characters (that's what the `.*` means - it's a [regular expression](http://localhost:17357/library/base/html/regex.html)), followed by `broadPeak` (to match the file extension of our MACS files).

```{r peak_files}
# Import peaks ----

# list peak files
brd4_files <- list.files(path = "preprocessed/nf-chipseq", 
                         pattern = "brd4_.*broadPeak", 
                         recursive = TRUE,
                         full.names = TRUE)
names(brd4_files) <- gsub("_peaks.broadPeak", "", 
                          basename(brd4_files))

brd4_files
```

We then apply the function `import()` to this list of files (using `lapply()`), which automatically generates `GRanges` objects from the BED files. 
We also make sure to bind them all together into a single `GRanges` object.

```{r peak_import}
# take the peak files, and then...
brd4_ranges <- brd4_files |> 
  # ... loop through and import them, and then...
  lapply(import, 
         format = "broadPeak") |> 
  # ... bind them all together
  bind_ranges(.id = "sample")

brd4_ranges
```

Finally, we do some tidying up, by keeping only chromosomes of interest (we get rid of contigs and the mitochondrial genome, for example) and adding genome information to our `GRanges`. 

```{r peak_tidy}
# subset ranges to contain only main chromosomes
brd4_ranges <- brd4_ranges[seqnames(brd4_ranges) %in% chroms$seqnames, ]
seqlevels(brd4_ranges) <- chroms$seqnames
brd4_ranges <- set_genome_info(brd4_ranges, 
                               genome = "GRCh38",
                               seqnames = chroms$seqnames,
                               seqlengths = chroms$seqlengths,
                               is_circular = chroms$is_circular)
```

You may have noticed earlier, when we loaded our packages, that we're using a package called `plyranges`. 
This package implements some functions from the popular data manipulation package `dplyr`, but for `GRanges` ([docs](https://www.bioconductor.org/packages/devel/bioc/vignettes/plyranges/inst/doc/an-introduction.html)). 
For example, here we use the function `mutate()` to add a new column, indicating which treatment our samples belong to:

```{r, range_mutate}
# add treatment variable
brd4_ranges <- brd4_ranges |> 
  mutate(treatment = ifelse(grepl("_e2_", sample), "e2", "veh"))
```


## Peak occupancy

Now that we have our `GRanges` object, we can calculate the coverage across intervals of our genome, i.e. how many intervals in our genome are covered 1, 2, 3, 4, etc. times. 
In our case, this is equivalent to asking how many samples have overlapping peaks in a given interval. 

We do this using the `compute_coverage()` function (notice how we also use the `filter()` function, analogous to the `dplyr::filter()` function to subset rows of our `GRanges` based on a condition):

```{r peak_coverage}
# Coverage ranges ----

# calculate coverage across genome
brd4_coverage <- brd4_ranges |> 
  compute_coverage()

# visualise occupancy rates
brd4_coverage |> 
  # remove intervals with no coverage at all
  filter(score > 0) |> 
  # convert to data.frame
  as.data.frame() |> 
  # barplot of counts for each coverage score
  ggplot(aes(x = score)) + 
  geom_bar() +
  scale_x_continuous(breaks = 1:6) +
  labs(x = "# overlaps")
```

We can see from our barplot that the frequency drops substantially from 1 to 2 overlaps, by more than half.
This may indicate some quality issues with our samples, for example due to unequal FRiP scores (fraction of reads mapped to called peaks), which we've seen was an issue from our `nf-core/chipseq` MultiQC report.

We can now generate a set of consensus peaks by doing the following:

- identify intervals that have a coverage of at least 2;
- filter our original intervals based on the coverage > 2 intervals;
- optionally, we also merge intervals within 1kb of each other (you can adjust this, based on your knowledge of the biology).

```{r peak_consensus}
# get intervals with coverage >= 2
brd4_coverage2 <- brd4_coverage |> 
  filter(score >= 2)

# create consensus peak intervals
brd4_consensus <- brd4_ranges |> 
  # filter to retain ranges with enough coverage
  filter_by_overlaps(brd4_coverage2) |> 
  # merge ranges within 1kb of each other
  reduce(min.gapwidth = 1e3)
```

Using this method, we have `r length(brd4_consensus)` intervals. 

At this stage, we could export these intervals as a BED file, to use in other downstream analysis, or to load into IGV: 

```{r write_bed, eval=FALSE, purl=FALSE}
write_bed(brd4_consensus, "results/brd4_consensus_overlap2.bed")
```


## Annotate peaks

Another useful task we can do is to annotate our peaks based on known gene annotations. 
We've already seen how this is done by the `nf-core/chipseq` workflow (which uses the [HOMER software](http://homer.ucsd.edu/homer/) behind the scenes), but we'll demonstrate how you can also annotate `GRanges` objects from within R. 

The first thing we do is import the GTF file as a `TxDb` object (this is another standard Bioconductor object used to store gene annotations in a database-like object). 
We then use the `annotatePeak()` function (part of the `ChIPseeker` package), which adds columns to our `GRanges` object with the annotation outcome. 

```{r peak_annotate}
# Annotate peaks ----

# import GTF as a TxDb object
genes <- GenomicFeatures::makeTxDbFromGFF("resources/GRCh38.109.gtf.gz")

# we use ChIPseeker to annotate the peaks
brd4_consensus <- brd4_consensus |> 
  annotatePeak(tssRegion = c(-3e3, 3e3),
               TxDb = genes) |> 
  # convert back to GRanges
  as.GRanges()

brd4_consensus
```

This new annotate object can be used, for example, to visualise how many peaks have each annotation: 

```{r annotation_barplot}  
# barplot of annotations
brd4_consensus |> 
  # remove gene IDs from exon/intro annotations for cleaner plot
  mutate(annotation = gsub("Exon .*", "Exon", annotation)) |> 
  mutate(annotation = gsub("Intron .*", "Intron", annotation)) |> 
  # make plot
  as.data.frame() |> 
  ggplot(aes(annotation)) +
  geom_bar() +
  coord_flip()
```

We can see that most peaks are within 1kb of the promoter region of the annotated transcripts.
We might expect this to be the case, as we'd seen earlier from the read distribution profiles (on the MultiQC report from `nf-core/chipseq`) that BRD4 seems to occur upstream of the TSS. 


## Exercise: H2Bub1 peaks

:::{.callout-exercise}

```{r ex_header, echo=FALSE}

# Exercise ----
```

We now want to do a similar analysis for the H2Bub1 histone ChIP. 
In summary, we want to: 

- Import all the H2Bub1 broadPeak files generated by MACS into a `GRanges` object.
- Calculate interval coverage and visualise it as a barplot. 
- Create a `GRanges` object of consensus peaks called in at least 2 samples. 
- Make a barplot of annotations.

While you do this analysis, what can you conclude about the differences between H2Bub1 and BRD4 in terms of their ChIP profiles?

We already provide a code skeleton for you to do this, with some "FIXME" for you to correct. 

<details><summary>Code skeleton</summary>

Note, this code is provided in the accompanying course materials script. 
It's only shown here for reference. 

```{r ex_h2bub, eval=FALSE}
# !!!FIX!!! list peak files 
h2bub1_files <- list.files(path = "preprocessed/nf-chipseq",
                           pattern = "FIXME",
                           recursive = TRUE,
                           full.names = TRUE)
names(h2bub1_files) <- gsub("_peaks.broadPeak", "",
                            basename(h2bub1_files))

# take the peak files, and then...
h2bub1_ranges <- h2bub1_files |>
  # ... loop through and import them, and then...
  lapply(import,
         format = "broadPeak") |>
  # ... bind them all together
  bind_ranges(.id = "sample")

# subset ranges to contain only main chromosomes
h2bub1_ranges <- h2bub1_ranges[seqnames(h2bub1_ranges) %in% chroms$seqnames, ]
seqlevels(h2bub1_ranges) <- chroms$seqnames
h2bub1_ranges <- set_genome_info(h2bub1_ranges,
                                 genome = "GRCh38",
                                 seqnames = chroms$seqnames,
                                 seqlengths = chroms$seqlengths,
                                 is_circular = chroms$is_circular)

# add treatment variable
h2bub1_ranges <- h2bub1_ranges |>
  mutate(treatment = ifelse(grepl("_e2_", sample), "e2", "veh"))

# !!!FIX!!! calculate coverage across genome
h2bub1_coverage <- FIXME

# occupancy rates
h2bub1_coverage |>
  # remove intervals with no coverage at all
  filter(score > 0) |>
  # convert to data.frame
  as.data.frame() |>
  # barplot of counts for each coverage score
  ggplot(aes(x = score)) +
  geom_bar() +
  scale_x_continuous(breaks = 1:6) +
  labs(x = "# overlaps")

# !!!FIX!!! get intervals with coverage >= 2
h2bub1_coverage2 <- FIXME

# !!!FIX!!! create consensus peak intervals
h2bub1_consensus <- h2bub1_ranges |>
  # filter to retain ranges with enough coverage
  FIXME |>
  # merge ranges within 1kb of each other
  reduce(min.gapwidth = 1e3)

# !!!FIX!!! use ChIPseeker to annotate the peaks
h2bub1_consensus <- FIXME

# barplot of annotations
h2bub1_consensus |>
  # remove gene IDs from exon/intro annotations for cleaner plot
  mutate(annotation = gsub("Exon .*", "Exon", annotation)) |>
  mutate(annotation = gsub("Intron .*", "Intron", annotation)) |>
  # make plot
  as.data.frame() |>
  ggplot(aes(annotation)) +
  geom_bar() +
  coord_flip()
```

</details>

:::{.callout-answer collapse=true}

The complete analysis code is shown here:

```{r ex_answer_h2bub1, purl=FALSE}
# list peak files
h2bub1_files <- list.files(path = "preprocessed/nf-chipseq", 
                           pattern = "h2bub1_.*.broadPeak", 
                           recursive = TRUE,
                           full.names = TRUE)
names(h2bub1_files) <- gsub("_peaks.broadPeak", "", 
                            basename(h2bub1_files))

# take the peak files, and then...
h2bub1_ranges <- h2bub1_files |> 
  # ... loop through and import them, and then...
  lapply(import, 
         format = "broadPeak") |> 
  # ... bind them all together
  bind_ranges(.id = "sample")
  
# subset ranges to contain only main chromosomes
h2bub1_ranges <- h2bub1_ranges[seqnames(h2bub1_ranges) %in% chroms$seqnames, ]
seqlevels(h2bub1_ranges) <- chroms$seqnames
h2bub1_ranges <- set_genome_info(h2bub1_ranges, 
                                 genome = "GRCh38",
                                 seqnames = chroms$seqnames,
                                 seqlengths = chroms$seqlengths,
                                 is_circular = chroms$is_circular)

# add treatment variable
h2bub1_ranges <- h2bub1_ranges |> 
  mutate(treatment = ifelse(grepl("_e2_", sample), "e2", "veh"))
  
# calculate coverage across genome
h2bub1_coverage <- h2bub1_ranges |> 
  compute_coverage()

# occupancy rates
h2bub1_coverage |> 
  # remove intervals with no coverage at all
  filter(score > 0) |> 
  # convert to data.frame
  as.data.frame() |> 
  # barplot of counts for each coverage score
  ggplot(aes(x = score)) + 
  geom_bar() +
  scale_x_continuous(breaks = 1:6) +
  labs(x = "# overlaps")

# get intervals with coverage >= 2
h2bub1_coverage2 <- h2bub1_coverage |> 
  filter(score >= 2)

# create consensus peak intervals
h2bub1_consensus <- h2bub1_ranges |> 
  # filter to retain ranges with enough coverage
  filter_by_overlaps(h2bub1_coverage2) |> 
  # merge ranges within 1kb of each other
  reduce(min.gapwidth = 1e3)
  
# use ChIPseeker to annotate the peaks
h2bub1_consensus <- h2bub1_consensus |> 
  annotatePeak(tssRegion = c(-3e3, 3e3),
               TxDb = genes) |> 
  as.GRanges()

# barplot of annotations
h2bub1_consensus |> 
  # remove gene IDs from exon/intro annotations for cleaner plot
  mutate(annotation = gsub("Exon .*", "Exon", annotation)) |> 
  mutate(annotation = gsub("Intron .*", "Intron", annotation)) |> 
  # make plot
  as.data.frame() |> 
  ggplot(aes(annotation)) +
  geom_bar() +
  coord_flip()
```

Looking at these results we can conclude that: 

- H2Bub1 signals are much more consistent across replicates, with hardly a drop in the frequency of intervals with overlap 2 or even 3. 
- A much higher fraction of peaks fall in introns, promoters and exons, which makes sense because we had previously seen that H2Bub1 seems to occupy gene bodies. 

:::

:::


## Cross-reference datasets

Often ChIP-seq experiments might be complemented with RNA-seq experiments, to assess changes in gene expression in comparable conditions to those where the ChIP experiment was performed. 
If that is the case, we may want to cross-reference our annotated peaks with the results from the RNA-seq analysis. 

We have obtained a list of differentially expressed genes between control and siBRD4 MCF7 cells from the supplementary data in [Nagarajan et al. 2017](https://doi.org/10.1093/nar/gkw1276).
This should give an indication of which genes change their expression in a BRD4-dependent manner, which may be relevant for us to further filter and/or interpret our peaks. 

In the code below we start by reading the CSV file with differentially expressed gene IDs, which we then use to filter our annotated consensus peak list. 

```{r peak_subset}
# Subset peaks ----

# read DEGs from Nagarajan 2017
degs <- read.csv("resources/degs_nagarajan2017.csv")

# subset annotated intervals
brd4_consensus_degs <- brd4_consensus |> 
  filter(geneId %in% degs$ensembl_gene_id)
```

We are left with `r length(brd4_consensus_degs)` intervals.

We will continue working with this subset of peaks in the next section, to compare the ChIP profiles between differentially expressed genes and other genes. 

