{
  "hash": "ea605ef0d5dd069618cd0f574cbdbfe0",
  "result": {
    "markdown": "---\ntitle: Exploring peak ranges\n---\n\n::: {.cell}\n\n:::\n\n::: {.cell hash='../_cache/purl_081d8264658d47a90bb4079eb05b2d20'}\n\n:::\n\n\n\n::: {.callout-tip}\n#### Learning Objectives\n\n- Import and manipulate peak ranges with dedicated R/Bioconductor packages.\n- Become familiar with `GRanges` objects and how to use them for interval-based operations.\n- Calculate and visualise peak occupancy across replicates. \n- Annotate peaks based on known gene annotations.\n- Visualise peak profiles as a heatmap.\n\n:::\n\n## Peak ranges\n\nAlthough the `nf-core/chipseq` workflow generates a peak consensus BED file, it is useful to know how to read and manipulate peak files ourselves. \nFor example, we may want to change our criteria for defining a consensus peak (e.g. require an overlap across more replicates), annotate our peaks, or filter them based on different criteria. \n\nIn this section, we will see how we can achieve this using dedicated R/Bioconductor packages, designed to work with genomic interval data. \nThe main object used to represent genome intervals in R is called `GRanges`, which is part of the [Bioconductor GenomicRanges package](https://bioconductor.org/packages/release/bioc/vignettes/GenomicRanges/inst/doc/GenomicRangesIntroduction.html). \n\nThis object requires at least three pieces of information:\n\n- chromosome names (`seqnames`);\n- interval start and end positions (`ranges`);\n- and strand orientation, either `+` forward or `-` reverse (`strand`).\n\nIn addition, further columns can store additional information, such GC content in the interval, gene annotations overlapping that interval, etc.\nHere is an example of a simple `GRanges` object:\n\n\n::: {.cell hash='../_cache/granges_demo1_d8a8963f86453d504543da656c3a9a6f'}\n::: {.cell-output .cell-output-stdout}\n```\nGRanges object with 10 ranges and 2 metadata columns:\n    seqnames    ranges strand |     score        GC\n       <Rle> <IRanges>  <Rle> | <integer> <numeric>\n  a     chr1   101-111      - |         1  1.000000\n  b     chr2   102-112      + |         2  0.888889\n  c     chr2   103-113      + |         3  0.777778\n  d     chr2   104-114      * |         4  0.666667\n  e     chr1   105-115      * |         5  0.555556\n  f     chr1   106-116      + |         6  0.444444\n  g     chr3   107-117      + |         7  0.333333\n  h     chr3   108-118      + |         8  0.222222\n  i     chr3   109-119      - |         9  0.111111\n  j     chr3   110-120      - |        10  0.000000\n  -------\n  seqinfo: 3 sequences from example genome\n```\n:::\n:::\n\n\nHere is a quick summary of functions used to access information from `GRanges` objects (the example code assumes the object is called `gr`):\n\n\n::: {.cell hash='../_cache/granges_demo2_e621c79ed88dd057e93ec1ac1492d5af'}\n\n```{.r .cell-code}\n# total number of intervals\nlength(gr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 10\n```\n:::\n\n```{.r .cell-code}\n# sequence names (usually chromosomes)\n# with number of intervals for each \nseqnames(gr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfactor-Rle of length 10 with 4 runs\n  Lengths:    1    3    2    4\n  Values : chr1 chr2 chr1 chr3\nLevels(3): chr1 chr2 chr3\n```\n:::\n\n```{.r .cell-code}\n# sequence names only\nseqlevels(gr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"chr1\" \"chr2\" \"chr3\"\n```\n:::\n\n```{.r .cell-code}\n# sequence (chromosome) lengths\nseqlengths(gr)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   chr1    chr2    chr3 \n1000000  200000   10000 \n```\n:::\n:::\n\n\nThis type of object is ideal to represent ChIP peak calls, such as those identified by the MACS software. \nIn the following sections we will show a concrete example of this in action. \n\n## Import peak files\n\nTo start our analysis, we start by loading the packages we will use:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Packages ----\n\n# load packages\nlibrary(rtracklayer) # for importing BED/GFF/etc.\nlibrary(plyranges)   # for working with GenomicRanges\nlibrary(ChIPseeker)  # to annotate peaks\nlibrary(profileplyr) # for profile heatmaps\nlibrary(ggplot2)\n\n# change the default ggplot theme\ntheme_set(theme_classic(base_size = 14))\n```\n:::\n\n\nThe next step is to read information about our chromosome lengths, which is useful to make sure our `GRanges` object uses the correct information for our organism. \nWe generated this information from our reference genome FASTA file and stored it as a tab-delimited file, which we read using standard R functions: \n\n\n::: {.cell hash='../_cache/read_chroms_2bbb3eb4cf193261ccdb407754f35fba'}\n\n```{.r .cell-code}\n# Chromosome info ----\n\n# read chromosome sizes (for GRanges annotation)\nchroms <- read.table(\"resources/GRCh38.109.chrom_sizes.tsv\", \n                     col.names = c(\"seqnames\", \"seqlengths\"))\n\n# order chromosomes in a more intuititve manner\n# and retain only autosomes (no contigs, no MT)\nchroms <- chroms[match(c(1:22, \"X\", \"Y\"), chroms$seqnames), ]\n\n# if you had MT, you can use this code to set it as circular\nchroms$is_circular <- chroms$seqnames == \"MT\"\n\n# view table\nchroms\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   seqnames seqlengths is_circular\n1         1  248956422       FALSE\n12        2  242193529       FALSE\n16        3  198295559       FALSE\n17        4  190214555       FALSE\n18        5  181538259       FALSE\n19        6  170805979       FALSE\n20        7  159345973       FALSE\n21        8  145138636       FALSE\n22        9  138394717       FALSE\n2        10  133797422       FALSE\n3        11  135086622       FALSE\n4        12  133275309       FALSE\n5        13  114364328       FALSE\n6        14  107043718       FALSE\n7        15  101991189       FALSE\n8        16   90338345       FALSE\n9        17   83257441       FALSE\n10       18   80373285       FALSE\n11       19   58617616       FALSE\n13       20   64444167       FALSE\n14       21   46709983       FALSE\n15       22   50818468       FALSE\n24        X  156040895       FALSE\n25        Y   57227415       FALSE\n```\n:::\n:::\n\n\nBecause we have several peak files generated by MACS (one per sample and antibody), we will use some programmatic tricks to import them automatically, rather than having to repeat our code dozens of times. \n\nFirst, we find all the files that start with the word `brd4_`, followed by any characters (that's what the `.*` means - it's a [regular expression](http://localhost:17357/library/base/html/regex.html)), followed by `broadPeak` (to match the file extension of our MACS files).\n\n\n::: {.cell hash='../_cache/peak_files_6a52ef08fa56c627fcb4d1388d2d6db0'}\n\n```{.r .cell-code}\n# Import peaks ----\n\n# list peak files\nbrd4_files <- list.files(path = \"preprocessed/nf-chipseq\", \n                         pattern = \"brd4_.*broadPeak\", \n                         recursive = TRUE,\n                         full.names = TRUE)\nnames(brd4_files) <- gsub(\"_peaks.broadPeak\", \"\", \n                          basename(brd4_files))\n\nbrd4_files\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n                                                                             brd4_e2_rep1 \n \"preprocessed/nf-chipseq/bwa/mergedLibrary/macs2/broadPeak/brd4_e2_rep1_peaks.broadPeak\" \n                                                                             brd4_e2_rep2 \n \"preprocessed/nf-chipseq/bwa/mergedLibrary/macs2/broadPeak/brd4_e2_rep2_peaks.broadPeak\" \n                                                                             brd4_e2_rep3 \n \"preprocessed/nf-chipseq/bwa/mergedLibrary/macs2/broadPeak/brd4_e2_rep3_peaks.broadPeak\" \n                                                                            brd4_veh_rep1 \n\"preprocessed/nf-chipseq/bwa/mergedLibrary/macs2/broadPeak/brd4_veh_rep1_peaks.broadPeak\" \n                                                                            brd4_veh_rep2 \n\"preprocessed/nf-chipseq/bwa/mergedLibrary/macs2/broadPeak/brd4_veh_rep2_peaks.broadPeak\" \n                                                                            brd4_veh_rep3 \n\"preprocessed/nf-chipseq/bwa/mergedLibrary/macs2/broadPeak/brd4_veh_rep3_peaks.broadPeak\" \n```\n:::\n:::\n\n\nWe then apply the function `import()` to this list of files (using `lapply()`), which automatically generates `GRanges` objects from the BED files. \nWe also make sure to bind them all together into a single `GRanges` object.\n\n\n::: {.cell hash='../_cache/peak_import_0c43d7e3f2f7c9dc82a398ad9516dd13'}\n\n```{.r .cell-code}\n# take the peak files, and then...\nbrd4_ranges <- brd4_files |> \n  # ... loop through and import them, and then...\n  lapply(import, \n         format = \"broadPeak\") |> \n  # ... bind them all together\n  bind_ranges(.id = \"sample\")\n\nbrd4_ranges\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGRanges object with 76318 ranges and 6 metadata columns:\n          seqnames              ranges strand |                   name\n             <Rle>           <IRanges>  <Rle> |            <character>\n      [1]        1       778916-779334      * |    brd4_e2_rep1_peak_1\n      [2]        1       923724-925774      * |    brd4_e2_rep1_peak_2\n      [3]        1       940347-941420      * |    brd4_e2_rep1_peak_3\n      [4]        1       958835-959478      * |    brd4_e2_rep1_peak_4\n      [5]        1       966575-967254      * |    brd4_e2_rep1_peak_5\n      ...      ...                 ...    ... .                    ...\n  [76314]        X 154019432-154019886      * | brd4_veh_rep3_peak_2..\n  [76315]        X 154397616-154398734      * | brd4_veh_rep3_peak_2..\n  [76316]        X 154411351-154412020      * | brd4_veh_rep3_peak_2..\n  [76317]        X 154428300-154428959      * | brd4_veh_rep3_peak_2..\n  [76318]        X 154478146-154478744      * | brd4_veh_rep3_peak_2..\n              score signalValue    pValue    qValue        sample\n          <numeric>   <numeric> <numeric> <numeric>         <Rle>\n      [1]        12     3.27391   3.64994   1.20458  brd4_e2_rep1\n      [2]        27     4.32637   5.48032   2.74516  brd4_e2_rep1\n      [3]        21     3.98874   4.85482   2.18338  brd4_e2_rep1\n      [4]        18     3.75835   4.45139   1.84186  brd4_e2_rep1\n      [5]        24     4.13079   5.13008   2.44575  brd4_e2_rep1\n      ...       ...         ...       ...       ...           ...\n  [76314]        17     4.20761   5.26363   1.73490 brd4_veh_rep3\n  [76315]        26     4.67337   6.33105   2.65508 brd4_veh_rep3\n  [76316]        28     4.90174   6.59650   2.85383 brd4_veh_rep3\n  [76317]        18     4.27710   5.40107   1.85129 brd4_veh_rep3\n  [76318]        16     4.13966   5.13316   1.62427 brd4_veh_rep3\n  -------\n  seqinfo: 54 sequences from an unspecified genome; no seqlengths\n```\n:::\n:::\n\n\nFinally, we do some tidying up, by keeping only chromosomes of interest (we get rid of contigs and the mitochondrial genome, for example) and adding genome information to our `GRanges`. \n\n\n::: {.cell hash='../_cache/peak_tidy_1a615d1ff49960b9567ae95600f4e238'}\n\n```{.r .cell-code}\n# subset ranges to contain only main chromosomes\nbrd4_ranges <- brd4_ranges[seqnames(brd4_ranges) %in% chroms$seqnames, ]\nseqlevels(brd4_ranges) <- chroms$seqnames\nbrd4_ranges <- set_genome_info(brd4_ranges, \n                               genome = \"GRCh38\",\n                               seqnames = chroms$seqnames,\n                               seqlengths = chroms$seqlengths,\n                               is_circular = chroms$is_circular)\n```\n:::\n\n\nYou may have noticed earlier, when we loaded our packages, that we're using a package called `plyranges`. \nThis package implements some functions from the popular data manipulation package `dplyr`, but for `GRanges` ([docs](https://www.bioconductor.org/packages/devel/bioc/vignettes/plyranges/inst/doc/an-introduction.html)). \nFor example, here we use the function `mutate()` to add a new column, indicating which treatment our samples belong to:\n\n\n::: {.cell hash='../_cache/range_mutate_9b14dd73c2b5c606bd3018d60f4b8d8c'}\n\n```{.r .cell-code}\n# add treatment variable\nbrd4_ranges <- brd4_ranges |> \n  mutate(treatment = ifelse(grepl(\"_e2_\", sample), \"e2\", \"veh\"))\n```\n:::\n\n\n\n## Peak occupancy\n\nNow that we have our `GRanges` object, we can calculate the coverage across intervals of our genome, i.e. how many intervals in our genome are covered 1, 2, 3, 4, etc. times. \nIn our case, this is equivalent to asking how many samples have overlapping peaks in a given interval. \n\nWe do this using the `compute_coverage()` function (notice how we also use the `filter()` function, analogous to the `dplyr::filter()` function to subset rows of our `GRanges` based on a condition):\n\n\n::: {.cell hash='../_cache/peak_coverage_b240e59574408af2cc8d286f53da3ea6'}\n\n```{.r .cell-code}\n# Coverage ranges ----\n\n# calculate coverage across genome\nbrd4_coverage <- brd4_ranges |> \n  compute_coverage()\n\n# visualise occupancy rates\nbrd4_coverage |> \n  # remove intervals with no coverage at all\n  filter(score > 0) |> \n  # convert to data.frame\n  as.data.frame() |> \n  # barplot of counts for each coverage score\n  ggplot(aes(x = score)) + \n  geom_bar() +\n  scale_x_continuous(breaks = 1:6) +\n  labs(x = \"# overlaps\")\n```\n\n::: {.cell-output-display}\n![](02-peak_ranges_files/figure-html/peak_coverage-1.png){width=672}\n:::\n:::\n\n\nWe can see from our barplot that the frequency drops substantially from 1 to 2 overlaps, by more than half.\nThis may indicate some quality issues with our samples, for example due to unequal FRiP scores (fraction of reads mapped to called peaks), which we've seen was an issue from our `nf-core/chipseq` MultiQC report.\n\nWe can now generate a set of consensus peaks by doing the following:\n\n- identify intervals that have a coverage of at least 2;\n- filter our original intervals based on the coverage > 2 intervals;\n- optionally, we also merge intervals within 1kb of each other (you can adjust this, based on your knowledge of the biology).\n\n\n::: {.cell hash='../_cache/peak_consensus_24ba1dbab7f94095cc6a272c3a2d66c0'}\n\n```{.r .cell-code}\n# get intervals with coverage >= 2\nbrd4_coverage2 <- brd4_coverage |> \n  filter(score >= 2)\n\n# create consensus peak intervals\nbrd4_consensus <- brd4_ranges |> \n  # filter to retain ranges with enough coverage\n  filter_by_overlaps(brd4_coverage2) |> \n  # merge ranges within 1kb of each other\n  reduce(min.gapwidth = 1e3)\n```\n:::\n\n\nUsing this method, we have 11481 intervals. \n\nAt this stage, we could export these intervals as a BED file, to use in other downstream analysis, or to load into IGV: \n\n\n::: {.cell hash='../_cache/write_bed_e0f534a8c2c5604abbf6642a4af8fd13'}\n\n```{.r .cell-code}\nwrite_bed(brd4_consensus, \"results/brd4_consensus_overlap2.bed\")\n```\n:::\n\n\n\n## Annotate peaks\n\nAnother useful task we can do is to annotate our peaks based on known gene annotations. \nWe've already seen how this is done by the `nf-core/chipseq` workflow (which uses the [HOMER software](http://homer.ucsd.edu/homer/) behind the scenes), but we'll demonstrate how you can also annotate `GRanges` objects from within R. \n\nThe first thing we do is import the GTF file as a `TxDb` object (this is another standard Bioconductor object used to store gene annotations in a database-like object). \nWe then use the `annotatePeak()` function (part of the `ChIPseeker` package), which adds columns to our `GRanges` object with the annotation outcome. \n\n\n::: {.cell hash='../_cache/peak_annotate_74a535366573e944b46d35e16c8dd3fe'}\n\n```{.r .cell-code}\n# Annotate peaks ----\n\n# import GTF as a TxDb object\ngenes <- GenomicFeatures::makeTxDbFromGFF(\"resources/GRCh38.109.gtf.gz\")\n\n# we use ChIPseeker to annotate the peaks\nbrd4_consensus <- brd4_consensus |> \n  annotatePeak(tssRegion = c(-3e3, 3e3),\n               TxDb = genes) |> \n  # convert back to GRanges\n  as.GRanges()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n>> preparing features information...\t\t 2023-07-19 09:15:40 \n>> identifying nearest features...\t\t 2023-07-19 09:15:41 \n>> calculating distance from peak to TSS...\t 2023-07-19 09:15:41 \n>> assigning genomic annotation...\t\t 2023-07-19 09:15:41 \n>> assigning chromosome lengths\t\t\t 2023-07-19 09:15:59 \n>> done...\t\t\t\t\t 2023-07-19 09:15:59 \n```\n:::\n\n```{.r .cell-code}\nbrd4_consensus\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGRanges object with 11481 ranges and 9 metadata columns:\n          seqnames              ranges strand |       annotation   geneChr\n             <Rle>           <IRanges>  <Rle> |      <character> <integer>\n      [1]        1       778688-779334      * | Promoter (<=1kb)         1\n      [2]        1       923557-926380      * | Promoter (<=1kb)         1\n      [3]        1       939974-943307      * | Promoter (<=1kb)         1\n      [4]        1       958835-959478      * | Promoter (<=1kb)         1\n      [5]        1       966550-967254      * | Promoter (<=1kb)         1\n      ...      ...                 ...    ... .              ...       ...\n  [11477]        X 154762455-154764031      * | Promoter (<=1kb)        23\n  [11478]        X 155026794-155027456      * | Promoter (<=1kb)        23\n  [11479]        X 155070742-155071909      * | Promoter (<=1kb)        23\n  [11480]        X 155216022-155216875      * | Promoter (<=1kb)        23\n  [11481]        X 155612452-155613133      * | Promoter (<=1kb)        23\n          geneStart   geneEnd geneLength geneStrand          geneId\n          <integer> <integer>  <integer>  <integer>     <character>\n      [1]    778747    805994      27248          1 ENSG00000237491\n      [2]    923923    944574      20652          1 ENSG00000187634\n      [3]    940346    942173       1828          1 ENSG00000187634\n      [4]    944203    959256      15054          2 ENSG00000188976\n      [5]    966502    975008       8507          1 ENSG00000187583\n      ...       ...       ...        ...        ...             ...\n  [11477] 154762742 154777688      14947          1 ENSG00000130826\n  [11478] 155026844 155060304      33461          1 ENSG00000165775\n  [11479] 155061622 155071136       9515          2 ENSG00000182712\n  [11480] 155216460 155239841      23382          1 ENSG00000155959\n  [11481] 155612572 155738214     125643          1 ENSG00000168939\n             transcriptId distanceToTSS\n              <character>     <numeric>\n      [1] ENST00000655765             0\n      [2] ENST00000616016             0\n      [3] ENST00000478729             0\n      [4] ENST00000327044             0\n      [5] ENST00000379409            48\n      ...             ...           ...\n  [11477] ENST00000620277             0\n  [11478] ENST00000369498             0\n  [11479] ENST00000369484             0\n  [11480] ENST00000286428             0\n  [11481] ENST00000676089             0\n  -------\n  seqinfo: 24 sequences from an unspecified genome; no seqlengths\n```\n:::\n:::\n\n\nThis new annotate object can be used, for example, to visualise how many peaks have each annotation: \n\n\n::: {.cell hash='../_cache/annotation_barplot_caaaae1c9f34ce525de9ac57d502d58a'}\n\n```{.r .cell-code}\n# barplot of annotations\nbrd4_consensus |> \n  # remove gene IDs from exon/intro annotations for cleaner plot\n  mutate(annotation = gsub(\"Exon .*\", \"Exon\", annotation)) |> \n  mutate(annotation = gsub(\"Intron .*\", \"Intron\", annotation)) |> \n  # make plot\n  as.data.frame() |> \n  ggplot(aes(annotation)) +\n  geom_bar() +\n  coord_flip()\n```\n\n::: {.cell-output-display}\n![](02-peak_ranges_files/figure-html/annotation_barplot-1.png){width=672}\n:::\n:::\n\n\nWe can see that most peaks are within 1kb of the promoter region of the annotated transcripts.\nWe might expect this to be the case, as we'd seen earlier from the read distribution profiles (on the MultiQC report from `nf-core/chipseq`) that BRD4 seems to occur upstream of the TSS. \n\n\n## Exercise: H2Bub1 peaks\n\n:::{.callout-exercise}\n\n\n::: {.cell hash='../_cache/ex_header_a0af176e861c5684d73fc913780647f2'}\n\n:::\n\n\nWe now want to do a similar analysis for the H2Bub1 histone ChIP. \nIn summary, we want to: \n\n- Import all the H2Bub1 broadPeak files generated by MACS into a `GRanges` object.\n- Calculate interval coverage and visualise it as a barplot. \n- Create a `GRanges` object of consensus peaks called in at least 2 samples. \n- Make a barplot of annotations.\n\nWhile you do this analysis, what can you conclude about the differences between H2Bub1 and BRD4 in terms of their ChIP profiles?\n\nWe already provide a code skeleton for you to do this, with some \"FIXME\" for you to correct. \n\n<details><summary>Code skeleton</summary>\n\nNote, this code is provided in the accompanying course materials script. \nIt's only shown here for reference. \n\n\n::: {.cell hash='../_cache/ex_h2bub_5d2ba32d9de52ce37fa0e77b55ce3353'}\n\n```{.r .cell-code}\n# !!!FIX!!! list peak files \nh2bub1_files <- list.files(path = \"preprocessed/nf-chipseq\",\n                           pattern = \"FIXME\",\n                           recursive = TRUE,\n                           full.names = TRUE)\nnames(h2bub1_files) <- gsub(\"_peaks.broadPeak\", \"\",\n                            basename(h2bub1_files))\n\n# take the peak files, and then...\nh2bub1_ranges <- h2bub1_files |>\n  # ... loop through and import them, and then...\n  lapply(import,\n         format = \"broadPeak\") |>\n  # ... bind them all together\n  bind_ranges(.id = \"sample\")\n\n# subset ranges to contain only main chromosomes\nh2bub1_ranges <- h2bub1_ranges[seqnames(h2bub1_ranges) %in% chroms$seqnames, ]\nseqlevels(h2bub1_ranges) <- chroms$seqnames\nh2bub1_ranges <- set_genome_info(h2bub1_ranges,\n                                 genome = \"GRCh38\",\n                                 seqnames = chroms$seqnames,\n                                 seqlengths = chroms$seqlengths,\n                                 is_circular = chroms$is_circular)\n\n# add treatment variable\nh2bub1_ranges <- h2bub1_ranges |>\n  mutate(treatment = ifelse(grepl(\"_e2_\", sample), \"e2\", \"veh\"))\n\n# !!!FIX!!! calculate coverage across genome\nh2bub1_coverage <- FIXME\n\n# occupancy rates\nh2bub1_coverage |>\n  # remove intervals with no coverage at all\n  filter(score > 0) |>\n  # convert to data.frame\n  as.data.frame() |>\n  # barplot of counts for each coverage score\n  ggplot(aes(x = score)) +\n  geom_bar() +\n  scale_x_continuous(breaks = 1:6) +\n  labs(x = \"# overlaps\")\n\n# !!!FIX!!! get intervals with coverage >= 2\nh2bub1_coverage2 <- FIXME\n\n# !!!FIX!!! create consensus peak intervals\nh2bub1_consensus <- h2bub1_ranges |>\n  # filter to retain ranges with enough coverage\n  FIXME |>\n  # merge ranges within 1kb of each other\n  reduce(min.gapwidth = 1e3)\n\n# !!!FIX!!! use ChIPseeker to annotate the peaks\nh2bub1_consensus <- FIXME\n\n# barplot of annotations\nh2bub1_consensus |>\n  # remove gene IDs from exon/intro annotations for cleaner plot\n  mutate(annotation = gsub(\"Exon .*\", \"Exon\", annotation)) |>\n  mutate(annotation = gsub(\"Intron .*\", \"Intron\", annotation)) |>\n  # make plot\n  as.data.frame() |>\n  ggplot(aes(annotation)) +\n  geom_bar() +\n  coord_flip()\n```\n:::\n\n\n</details>\n\n:::{.callout-answer collapse=true}\n\nThe complete analysis code is shown here:\n\n\n::: {.cell hash='../_cache/ex_answer_h2bub1_cf04f6802a9a93f0ca6ee5f7b42e1f73'}\n\n```{.r .cell-code}\n# list peak files\nh2bub1_files <- list.files(path = \"preprocessed/nf-chipseq\", \n                           pattern = \"h2bub1_.*.broadPeak\", \n                           recursive = TRUE,\n                           full.names = TRUE)\nnames(h2bub1_files) <- gsub(\"_peaks.broadPeak\", \"\", \n                            basename(h2bub1_files))\n\n# take the peak files, and then...\nh2bub1_ranges <- h2bub1_files |> \n  # ... loop through and import them, and then...\n  lapply(import, \n         format = \"broadPeak\") |> \n  # ... bind them all together\n  bind_ranges(.id = \"sample\")\n  \n# subset ranges to contain only main chromosomes\nh2bub1_ranges <- h2bub1_ranges[seqnames(h2bub1_ranges) %in% chroms$seqnames, ]\nseqlevels(h2bub1_ranges) <- chroms$seqnames\nh2bub1_ranges <- set_genome_info(h2bub1_ranges, \n                                 genome = \"GRCh38\",\n                                 seqnames = chroms$seqnames,\n                                 seqlengths = chroms$seqlengths,\n                                 is_circular = chroms$is_circular)\n\n# add treatment variable\nh2bub1_ranges <- h2bub1_ranges |> \n  mutate(treatment = ifelse(grepl(\"_e2_\", sample), \"e2\", \"veh\"))\n  \n# calculate coverage across genome\nh2bub1_coverage <- h2bub1_ranges |> \n  compute_coverage()\n\n# occupancy rates\nh2bub1_coverage |> \n  # remove intervals with no coverage at all\n  filter(score > 0) |> \n  # convert to data.frame\n  as.data.frame() |> \n  # barplot of counts for each coverage score\n  ggplot(aes(x = score)) + \n  geom_bar() +\n  scale_x_continuous(breaks = 1:6) +\n  labs(x = \"# overlaps\")\n```\n\n::: {.cell-output-display}\n![](02-peak_ranges_files/figure-html/ex_answer_h2bub1-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# get intervals with coverage >= 2\nh2bub1_coverage2 <- h2bub1_coverage |> \n  filter(score >= 2)\n\n# create consensus peak intervals\nh2bub1_consensus <- h2bub1_ranges |> \n  # filter to retain ranges with enough coverage\n  filter_by_overlaps(h2bub1_coverage2) |> \n  # merge ranges within 1kb of each other\n  reduce(min.gapwidth = 1e3)\n  \n# use ChIPseeker to annotate the peaks\nh2bub1_consensus <- h2bub1_consensus |> \n  annotatePeak(tssRegion = c(-3e3, 3e3),\n               TxDb = genes) |> \n  as.GRanges()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n>> preparing features information...\t\t 2023-07-19 09:16:28 \n>> identifying nearest features...\t\t 2023-07-19 09:16:28 \n>> calculating distance from peak to TSS...\t 2023-07-19 09:16:29 \n>> assigning genomic annotation...\t\t 2023-07-19 09:16:29 \n>> assigning chromosome lengths\t\t\t 2023-07-19 09:16:31 \n>> done...\t\t\t\t\t 2023-07-19 09:16:31 \n```\n:::\n\n```{.r .cell-code}\n# barplot of annotations\nh2bub1_consensus |> \n  # remove gene IDs from exon/intro annotations for cleaner plot\n  mutate(annotation = gsub(\"Exon .*\", \"Exon\", annotation)) |> \n  mutate(annotation = gsub(\"Intron .*\", \"Intron\", annotation)) |> \n  # make plot\n  as.data.frame() |> \n  ggplot(aes(annotation)) +\n  geom_bar() +\n  coord_flip()\n```\n\n::: {.cell-output-display}\n![](02-peak_ranges_files/figure-html/ex_answer_h2bub1-2.png){width=672}\n:::\n:::\n\n\nLooking at these results we can conclude that: \n\n- H2Bub1 signals are much more consistent across replicates, with hardly a drop in the frequency of intervals with overlap 2 or even 3. \n- A much higher fraction of peaks fall in introns, promoters and exons, which makes sense because we had previously seen that H2Bub1 seems to occupy gene bodies. \n\n:::\n\n:::\n\n\n## Cross-reference datasets\n\nOften ChIP-seq experiments might be complemented with RNA-seq experiments, to assess changes in gene expression in comparable conditions to those where the ChIP experiment was performed. \nIf that is the case, we may want to cross-reference our annotated peaks with the results from the RNA-seq analysis. \n\nWe have obtained a list of differentially expressed genes between control and siBRD4 MCF7 cells from the supplementary data in [Nagarajan et al. 2017](https://doi.org/10.1093/nar/gkw1276).\nThis should give an indication of which genes change their expression in a BRD4-dependent manner, which may be relevant for us to further filter and/or interpret our peaks. \n\nIn the code below we start by reading the CSV file with differentially expressed gene IDs, which we then use to filter our annotated consensus peak list. \n\n\n::: {.cell hash='../_cache/peak_subset_4e6ae7e5b411d909842483f1bdf63174'}\n\n```{.r .cell-code}\n# Subset peaks ----\n\n# read DEGs from Nagarajan 2017\ndegs <- read.csv(\"resources/degs_nagarajan2017.csv\")\n\n# subset annotated intervals\nbrd4_consensus_degs <- brd4_consensus |> \n  filter(geneId %in% degs$ensembl_gene_id)\n```\n:::\n\n\nWe are left with 397 intervals.\n\nWe will continue working with this subset of peaks in the next section, to compare the ChIP profiles between differentially expressed genes and other genes. \n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}