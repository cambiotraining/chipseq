{
  "hash": "43b0e27196bc4268c93be263f7ad5781",
  "result": {
    "markdown": "---\ntitle: Profile heatmaps\n---\n\n::: {.cell}\n\n:::\n\n::: {.cell hash='../_cache/purl_a9198e3c3110bfed63b78644b6b7308d'}\n\n:::\n\n\n\n::: {.callout-tip}\n#### Learning Objectives\n\n- Generate binned count matrices for producing profile plots.\n- Visualise peak profiles as a density plots and as a heatmap.\n\n:::\n\n## Profile heatmaps\n\nBefore we visualise our data as heatmaps, we need to generate a matrix of binned counts for every peak and around annotations of interest (usually genes). \nThis is a computationally-intense step, so for \"real\" analysis be sure to run this on a high-performance workstation or cluster (and be ready to wait for a while).\n\nThe binned counts matrix can be calculated using the `deeptools` suite. \nThere are a couple of steps involved: \n\n- Scale the counts of each sample by the respective input controls. \n  These are usually expressed as a ratio of counts on a log scale: log2(sample/input). \n- Generate a matrix of binned (scaled) counts around known genes. \n\nThe first step is achieved using the `bamCompare` (part of `deeptools`). \nHere is how we would generate these counts for one of our samples: \n\n```bash\nbamCompare \\\n  -b1 results/nf-chipseq/bwa/mergedLibrary/brd4_e2_rep1.mLb.clN.sorted.bam \\\n  -b2 results/nf-chipseq/bwa/mergedLibrary/mcf7_input_e2.mLb.clN.sorted.bam \\\n  -o results/deeptools/brd4_e2_rep1.log2.bigwig \\\n  --binSize 20 \\\n  --smoothLength 60 \\\n  -p 8\n```\n\nHere, we have: \n\n- `-b1` is the BAM file for our sample;\n- `-b2` is the BAM file for our input control;\n- `-o` is the output file (in bigwig format);\n- `--binSize` is the size of the bin (in bp) that we want to summarise the data by (default is 10). \n  The larger this number, the \"coarser\" the output will be, but it will also run faster and produce smaller files. \n- `--smoothLength` will smooth the signal by taking into account the signal of neighbouring regions. \n  This is useful for visualisation.\n- `-p` is the number of processors (CPUs) we want to use to run the analysis in parallel. \n  As mentioned earlier, these are a computationally intensive steps, so using more processors can help speed things up.\n\nThis analysis would have to be done for every single sample, so you may want to use some programmatic tricks to automate things (see tip box below). \n\n\n:::{.callout-note collapse=true}\n#### Looping samples through `bamCompare`\n\nOne way to run `bamCompare` across all our samples in an automated way is to use a \"[for loop](https://cambiotraining.github.io/unix-shell/materials/02-programming/03-loops.html)\"\nBelow is some code to illustrate this. \n\nWe take advantage that our files are named consistently to generate our `for` loop. \nIn the following example we loop through the E2-treated samples (you would have to write another similar loop for the vehicle samples, as they have a different input control).\n\n```bash\nfor file in results/nf-chipseq/bwa/mergedLibrary/*_e2_*.bam\ndo \n  # get the prefix from the BAM filename to generate output file\n  prefix=$(basename $file .mLb.clN.sorted.bam)\n\n  # print a message to the screen to keep track of things\n  echo \"bamCompare on ${file}\"\n\n  # run bamCompare\n  bamCompare \\\n    -b1 $file \\\n    -b2 results/nf-chipseq/bwa/mergedLibrary/mcf7_input_e2.mLb.clN.sorted.bam \\\n    -o results/deeptools/${prefix}.log2.bigwig \\\n    --binSize 20 \\\n    --smoothLength 60 \\\n    -p 8\ndone\n```\n\n:::\n\n\n### `computeMatrix`\n\nThe next step of our analysis is to create a matrix of binned counts for each peak and gene annotation. \nThis is done using the `computeMatrix` tool from `deeptools`.\n\nThere are two \"modes\" in which this tool can compute these counts: `reference-point` and `scale-regions`. \nThe difference between these is well illustrated in the [documentation](https://deeptools.readthedocs.io/en/latest/content/tools/computeMatrix.html).\n\n![Difference between the two modes for `computeMatrix`. Image source: [deeptools documentation](https://deeptools.readthedocs.io/en/latest/content/tools/computeMatrix.html).](https://deeptools.readthedocs.io/en/latest/_images/computeMatrix_modes.png)\n\nWhen to use one or the other depends on the type of protein being assessed. \nFor transcription factors, which typically bind to gene promoters, the `reference-point` mode probably makes sense, as it will show the signal around the TSS. \nFor proteins with broader signals, or that cover gene bodies (like our H2Bub1), the `scale-regions` might make more sense instead. \n\nHere is some the code we used to generate this matrix, using as input the scaled bigwig files from `bamCompare`:\n\n```bash\ncomputeMatrix scale-regions \\\n  --regionsFileName resources/GRCh38.109.gtf.gz \\\n  --scoreFileName results/deeptools/brd4_*.log2.bigwig \\\n  --outFileName results/deeptools/brd4.log2.mat.gz \\\n  --blackListFileName resources/ENCFF356LFX_exclusion_lists.bed.gz \\\n  --upstream 2000 \\\n  --downstream 2000 \\\n  --skipZeros \\\n  --binSize 20 \\\n  -p 8\n```\n\nWhere: \n\n- `--regionsFileName` is the name of the annotations we want to use to estimate the matrix of counts. \n  Typically the GTF of gene annotations is used (but you could use a different annotation, e.g. for a small subset of genes of interest). \n- `--scoreFileName` is the name of the files we want to calculate the binned counts on. \n  Notice how we use the `*` wildcard to match all the BRD4. \n- `--outFileName` is the name for the output file, which is automatically compressed using the 'gzip' algorithm (thus we save it with extension `.gz`).\n- `--blackListFileName` excludes regions falling in our exclusions list from being processed.\n- `--skipZeros` skips regions that have no counts.\n- `--upstream` and `--downstream` is the number of bp upstream and downstream of the TSS that we want to summarise counts, respectively. \n- `--binSize` and `-p` have the same meaning as above for `bamCompare`. \n\nThis step takes quite a while to run, so we have already generated these files for you (available from `preprocessed/deeptools/`).\n\n\n## Profile plots \n\nThere are two main types of profile plots that we can do: \n\n- Density plots showing the average signal of our peaks around our regions of interest (often genes).\n- A heatmap showing the signal of individual peaks around those same regions.\n\nOnce we have our binned count matrix, generating these is relatively simple using two `deeptools` commands. \n\nFor profile density plots we can use: \n\n```bash\nplotProfile -m preprocessed/deeptools/brd4.chr21.mat.gz -out results/brd4_profile.png\n```\n\nAnd for heatmaps we can do: \n\n```bash\nplotHeatmap -m preprocessed/deeptools/brd4.chr21.mat.gz -out results/brd4_heatmap.png\n```\n\nThere are several other options available with both of these tools (look at their documentation: [here](https://deeptools.readthedocs.io/en/latest/content/tools/plotProfile.html) and [here](https://deeptools.readthedocs.io/en/latest/content/tools/plotHeatmap.html)), including the ability to cluster the peaks using K-means clustering. \nWe will leave that as an optional exercise for the reader.\n\n\n## Profile heatmaps in R\n\nAlthough deeptools makes generating these plots relatively simple, we can also produce similar analysis using dedicated R/Bioconductor packages. \nThis has the advantage that it integrates well with our previous analysis in R. \n\nFirst, we set things up by loading our packages:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Packages ----\n\n# load packages\nlibrary(rtracklayer) # for importing BED/GFF/etc.\nlibrary(plyranges)   # for working with GenomicRanges\nlibrary(ChIPseeker)  # to annotate peaks\nlibrary(profileplyr) # for profile heatmaps\nlibrary(ggplot2)\n\n# change the default ggplot theme\ntheme_set(theme_classic(base_size = 14))\n```\n:::\n\n\nIf you haven't run the previous analysis of peaks, you can also read these in from pre-processed files we provide: \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# read consensus GRanges\nbrd4_consensus <- readRDS(\"preprocessed/r_objects/brd4_consensus_granges.rds\")\n```\n:::\n\n\nThe matrix of binned counts can be imported into R using the `Bioconductor/profileplyr` package. \n\n\n::: {.cell hash='../_cache/import_profile_c1cff1eb9eff82752d09cc56de7d64f1'}\n\n```{.r .cell-code}\n# Profile heatmaps ----\n\n# import the pre-computed matrix from deeptools\nbrd4_prof <- import_deepToolsMat(\"preprocessed/deeptools/brd4.log2.chr21.mat.gz\")\n\nbrd4_prof\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass: profileplyr \ndim: 3138 250 \nmetadata(0):\nassays(6): brd4_e2_rep1.log2 brd4_e2_rep2.log2 ... brd4_veh_rep2.log2\n  brd4_veh_rep3.log2\nrownames: NULL\nrowData names(3): names score dpGroup\ncolnames: NULL\ncolData names(0):\n```\n:::\n:::\n\n\nThe type of object returned is called a `profileplyr` object, which is a modified version of a `SummarizedExperiment` object, often used to store RNA-seq counts. \nWe won't go into the details of this object here, but you can find detailed information on the [package's vignette](https://www.bioconductor.org/packages/devel/bioc/vignettes/profileplyr/inst/doc/profileplyr.html#the-profileplyr-object). \n\nThe main things to consider for our purposes are: \n\n- The peak intervals (ranges) over which the data are summarised is available through the `rowRanges()` slot of the object. \n- The sample information is stored in the `sampleData()` slot of the object. \n- We can subset the object using `[` with the syntax as: `object[ranges, bins, samples]`.\n\nHere are some illustrative examples:\n\n\n::: {.cell hash='../_cache/subset_profiler_ae366b9d6e61698acabdd588d42ee158'}\n\n```{.r .cell-code}\n# ranges information\nrowRanges(brd4_prof)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nGRanges object with 3138 ranges and 3 metadata columns:\n         seqnames            ranges strand |           names       score\n            <Rle>         <IRanges>  <Rle> |     <character> <character>\n     [1]       21   8238858-8239092      + | ENST00000652328           .\n     [2]       21   8420674-8421003      + | ENST00000652246           .\n     [3]       21 10576291-10576587      + | ENST00000616920           .\n     [4]       21 10028360-10029855      - | ENST00000624662           .\n     [5]       21 13544209-13545185      - | ENST00000431829           .\n     ...      ...               ...    ... .             ...         ...\n  [3134]       21 25934340-25935178      + | ENST00000596669           .\n  [3135]       21 25941601-25952614      + | ENST00000667606           .\n  [3136]       21 25943043-25943145      - | ENST00000516163           .\n  [3137]       21 26158090-26175824      + | ENST00000455275           .\n  [3138]       21 26190706-26190813      + | ENST00000384075           .\n          dpGroup\n         <factor>\n     [1]    genes\n     [2]    genes\n     [3]    genes\n     [4]    genes\n     [5]    genes\n     ...      ...\n  [3134]    genes\n  [3135]    genes\n  [3136]    genes\n  [3137]    genes\n  [3138]    genes\n  -------\n  seqinfo: 1 sequence from an unspecified genome; no seqlengths\n```\n:::\n\n```{.r .cell-code}\n# sample information\nsampleData(brd4_prof)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDataFrame with 6 rows and 20 columns\n                    upstream downstream      body  bin.size unscaled.5.prime\n                   <numeric>  <numeric> <numeric> <numeric>        <numeric>\nbrd4_e2_rep1.log2       2000       2000      1000        20                0\nbrd4_e2_rep2.log2       2000       2000      1000        20                0\nbrd4_e2_rep3.log2       2000       2000      1000        20                0\nbrd4_veh_rep1.log2      2000       2000      1000        20                0\nbrd4_veh_rep2.log2      2000       2000      1000        20                0\nbrd4_veh_rep3.log2      2000       2000      1000        20                0\n                   unscaled.3.prime      sample_labels   verbose bin.avg.type\n                          <numeric>        <character> <logical>  <character>\nbrd4_e2_rep1.log2                 0  brd4_e2_rep1.log2     FALSE         mean\nbrd4_e2_rep2.log2                 0  brd4_e2_rep2.log2     FALSE         mean\nbrd4_e2_rep3.log2                 0  brd4_e2_rep3.log2     FALSE         mean\nbrd4_veh_rep1.log2                0 brd4_veh_rep1.log2     FALSE         mean\nbrd4_veh_rep2.log2                0 brd4_veh_rep2.log2     FALSE         mean\nbrd4_veh_rep3.log2                0 brd4_veh_rep3.log2     FALSE         mean\n                   missing.data.as.zero     scale skip.zeros nan.after.end\n                              <logical> <numeric>  <logical>     <logical>\nbrd4_e2_rep1.log2                 FALSE         1       TRUE         FALSE\nbrd4_e2_rep2.log2                 FALSE         1       TRUE         FALSE\nbrd4_e2_rep3.log2                 FALSE         1       TRUE         FALSE\nbrd4_veh_rep1.log2                FALSE         1       TRUE         FALSE\nbrd4_veh_rep2.log2                FALSE         1       TRUE         FALSE\nbrd4_veh_rep3.log2                FALSE         1       TRUE         FALSE\n                   proc.number sort.regions  sort.using ref.point min.threshold\n                     <numeric>  <character> <character>    <list>        <list>\nbrd4_e2_rep1.log2           10         keep        mean                        \nbrd4_e2_rep2.log2           10         keep        mean                        \nbrd4_e2_rep3.log2           10         keep        mean                        \nbrd4_veh_rep1.log2          10         keep        mean                        \nbrd4_veh_rep2.log2          10         keep        mean                        \nbrd4_veh_rep3.log2          10         keep        mean                        \n                   max.threshold generation.method\n                          <list>       <character>\nbrd4_e2_rep1.log2                        deepTools\nbrd4_e2_rep2.log2                        deepTools\nbrd4_e2_rep3.log2                        deepTools\nbrd4_veh_rep1.log2                       deepTools\nbrd4_veh_rep2.log2                       deepTools\nbrd4_veh_rep3.log2                       deepTools\n```\n:::\n\n```{.r .cell-code}\n# subset the object for:\n# first 10 peaks\n# first 5 bins\n# first 3 samples\nbrd4_prof[1:10, 1:5, 1:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nclass: profileplyr \ndim: 10 5 \nmetadata(0):\nassays(3): brd4_e2_rep1.log2 brd4_e2_rep2.log2 brd4_e2_rep3.log2\nrownames: NULL\nrowData names(3): names score dpGroup\ncolnames: NULL\ncolData names(0):\n```\n:::\n:::\n\n\nOne of the main functions provided in this package is the ability to produce profile heatmaps. \nThese heatmaps can be quite heavy to render graphically, so it's usually a good idea to subset our ranges. \n\nIn the following example, we sample a few random intervals to get an idea of occupancy for our BRD4 protein around genes:\n\n\n::: {.cell hash='../_cache/enriched_heatmap_fce6e40f9e2a262c70e519ebecd80c32'}\n\n```{.r .cell-code}\n# sample 200 peaks randomly\nrandom_peaks <- sample(1:nrow(brd4_prof), 200)\n\n# Plot random peaks to give an idea of occupancy\ngenerateEnrichedHeatmap(brd4_prof[random_peaks, ], \n                        include_group_annotation = FALSE)\n```\n\n::: {.cell-output-display}\n![](03-profile_heatmaps_files/figure-html/enriched_heatmap-1.png){width=672}\n:::\n:::\n\n\nWe can see that BRD4 mostly occupies gene promoters. \nThis result does not come as a complete surprise, as we had already seen this in previous analysis. \n\nFor heatmaps with thousands of peaks, it's best to save them as PNG, as the plotting device on RStudio can stuggle to render them. \nHere is an example for all Chr21 peaks we loaded in:\n\n\n::: {.cell hash='../_cache/unnamed-chunk-1_03197c2d96532dce98450240e955ab05'}\n\n```{.r .cell-code}\n# save as PNG - adjust width, height and resolution to fit your needs\npng(\"results/brd4_heatmap.png\", width = 3000, height = 1500, res = 300)\ngenerateEnrichedHeatmap(brd4_prof, include_group_annotation = FALSE)\ndev.off()\n```\n:::\n\n\nWe can subset our profile object to include only the peaks that overlap with another set of peaks of our interest. \nFor example, we could investigate if the profiles look very different for the set of genes that are differentially expressed in siBRD4 lines. \n\n\n::: {.cell hash='../_cache/profile_degs_0273a2c2c825d6758494ba1465b67033'}\n\n```{.r .cell-code}\n# read DEGs from Nagarajan 2017\ndegs <- read.csv(\"resources/degs_nagarajan2017.csv\")\n\n# subset annotated intervals \nbrd4_consensus_degs <- brd4_consensus |> \n  filter(geneId %in% degs$ensembl_gene_id)\n\n# subset our profile object to include only the filtered intervals\nbrd4_prof_degs <- brd4_prof |> \n  subsetByOverlaps(brd4_consensus_degs)\n  \n# visualise them\ngenerateEnrichedHeatmap(brd4_prof_degs, include_group_annotation = FALSE)\n```\n\n::: {.cell-output-display}\n![](03-profile_heatmaps_files/figure-html/profile_degs-1.png){width=672}\n:::\n:::\n\n\n\n## Exercise: heatmap\n\n:::{.callout-exercise}\n\nBased on the code we showed above, generate a profile heatmap for the H2Bub1 ChIP.\n\n- First import the matrix of binned counts using `import_deepToolsMat()` and save it into an object called `h2bub1_prof`.\n- Then generate a heatmap using the `generateEnrichedHeatmap()` function, making sure you save it as a PNG. \n\nDoes the result match your expectation from previous analysis?\n\n\n::: {.cell hash='../_cache/ex1_h2bub1_prof_e0c978e01a0da92261f0c9b71e71b938'}\n\n:::\n\n\n:::{.callout-answer collapse=true}\n\nHere is the code to import and generate a PNG file with our heatmap:\n\n\n::: {.cell hash='../_cache/ex_answer_heatmap_d3f63447e8a5ccc0511e268089f12fda'}\n\n```{.r .cell-code}\n# import the pre-computed matrix from deeptools\nh2bub1_prof <- import_deepToolsMat(\"preprocessed/deeptools/h2bub1.log2.chr21.mat.gz\")\n\n# save plot as PNG\npng(\"results/h2bub1_heatmap.png\", width = 3000, height = 1500, res = 300)\ngenerateEnrichedHeatmap(h2bub1_prof, include_group_annotation = FALSE)\ndev.off()\n```\n:::\n\n\nIn order to save space, we show a random subset of 200 genes below as an example:\n\n\n::: {.cell hash='../_cache/ex_answer_heatmap_part2_cc30e74bbaa34f6d3d4c297b3ed08b17'}\n::: {.cell-output-display}\n![](03-profile_heatmaps_files/figure-html/ex_answer_heatmap_part2-1.png){width=672}\n:::\n:::\n\n\nThe plot shows that H2Bub1 has broader peaks across whole gene bodies and promoters. \nThis fits with the the peak annotation we did earlier, which showed that most peaks occur in those regions. \n\n:::\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}